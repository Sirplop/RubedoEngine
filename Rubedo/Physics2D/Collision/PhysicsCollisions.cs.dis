using Microsoft.Xna.Framework;
using Rubedo.Lib;
using Rubedo.Physics2D.Collision.Shapes;
using Rubedo.Physics2D.Util;
using System;

namespace Rubedo.Physics2D.Collision;

/// <summary>
/// Collision detection for physics, getting the penetration depth and normal of collision.
/// </summary>
internal static class PhysicsCollisions
{
    #region Helper
    public static bool CheckCollide(IColliderShape shape1, IColliderShape shape2, ref Manifold result)
    {
        bool ret;
        switch (shape1.ShapeType)
        {
            case ShapeType.Circle:
                CircleShape circle1 = (CircleShape)shape1;
                switch (shape2.ShapeType)
                {
                    case ShapeType.Circle:
                        CircleShape circle2 = (CircleShape)shape2;
                        return CircleCircle(circle1.Transform.WorldPosition, circle1.Radius, circle2.Transform.WorldPosition, circle2.Radius, ref result);
                    case ShapeType.Box:
                        BoxShape box2 = (BoxShape)shape2;
                        return CirclePolygon(box2, circle1, ref result);
                    case ShapeType.Capsule:
                        CapsuleShape capsule2 = (CapsuleShape)shape2;
                        return CircleCapsule(circle1, capsule2, ref result);
                    case ShapeType.Polygon:
                        PolygonShape poly2 = (PolygonShape)shape2;
                        return CirclePolygon(poly2, circle1, ref result);
                }
                break;
            case ShapeType.Box:
                BoxShape box1 = (BoxShape)shape1;
                switch (shape2.ShapeType)
                {
                    case ShapeType.Circle:
                        CircleShape circle2 = (CircleShape)shape2;
                        ret = CirclePolygon(box1, circle2, ref result);
                        result.normal = -result.normal;
                        return ret;
                    case ShapeType.Box:
                        BoxShape box2 = (BoxShape)shape2;
                        return BoxBox(box1, box2, ref result);
                    case ShapeType.Capsule:
                        CapsuleShape capsule2 = (CapsuleShape)shape2;
                        ret = CapsulePolygon(capsule2, box1, ref result);
                        result.normal = -result.normal;
                        return ret;
                    case ShapeType.Polygon:
                        PolygonShape poly2 = (PolygonShape)shape2;
                        return PolygonPolygon(box1, poly2, ref result);
                }
                break;
            case ShapeType.Capsule:
                CapsuleShape capsule1 = (CapsuleShape)shape1;
                switch (shape2.ShapeType)
                {
                    case ShapeType.Circle:
                        CircleShape circle2 = (CircleShape)shape2;
                        ret = CircleCapsule(circle2, capsule1, ref result);
                        result.normal = -result.normal;
                        return ret;
                    case ShapeType.Box:
                        BoxShape box2 = (BoxShape)shape2;
                        return CapsulePolygon(capsule1, box2, ref result);
                    case ShapeType.Capsule:
                        CapsuleShape capsule2 = (CapsuleShape)shape2;
                        return CapsuleCapsule(capsule1, capsule2, ref result);
                    case ShapeType.Polygon:
                        PolygonShape poly2 = (PolygonShape)shape2;
                        return CapsulePolygon(capsule1, poly2, ref result);
                }
                break;
            case ShapeType.Polygon:
                PolygonShape poly1 = (PolygonShape)shape1;
                switch (shape2.ShapeType)
                {
                    case ShapeType.Circle:
                        CircleShape circle2 = (CircleShape)shape2;
                        ret = CirclePolygon(poly1, circle2, ref result);
                        result.normal = -result.normal;
                        return ret;
                    case ShapeType.Box:
                        BoxShape box2 = (BoxShape)shape2;
                        return PolygonPolygon(poly1, box2, ref result);
                    case ShapeType.Capsule:
                        CapsuleShape capsule2 = (CapsuleShape)shape2;
                        ret = CapsulePolygon(capsule2, poly1, ref result);
                        result.normal = -result.normal;
                        return ret;
                    case ShapeType.Polygon:
                        PolygonShape poly2 = (PolygonShape)shape2;
                        return PolygonPolygon(poly1, poly2, ref result);
                }
                break;
        }
        return false;
    }
    #endregion

    #region Circle
    public static bool CircleCircle(Vector2 circleCenter1, float circleRadius1, Vector2 circleCenter2,
                                      float circleRadius2, ref Manifold result)
    {
        float sqrDist = Vector2.DistanceSquared(circleCenter1, circleCenter2);
        if (sqrDist >= (circleRadius1 + circleRadius2) * (circleRadius1 + circleRadius2))
        {
            return false;
        }
        Contact contact = result.GetContact(0);
        if (sqrDist == 0)
        { //consentric circles get arbitrary values.
            result.normal = Vector2.UnitY;
            contact.penetration = MathF.Max(circleRadius1, circleRadius2) * 0.5f;
            contact.position = result.normal * circleRadius1 + circleCenter1;
        }
        else
        {
            result.normal = Lib.Math.Normalize(circleCenter2 - circleCenter1);
            contact.penetration = circleRadius1 + circleRadius2 - MathF.Sqrt(sqrDist);
            contact.position = circleCenter1 + result.normal * circleRadius2;
        }
        result.contactCount = 1;
        return true;
    }
    public static bool CircleBox(CircleShape circle, BoxShape box, ref Manifold result)
    {
        // Boxes that have undergone rotations must be calculated as polygons.
        if (box.Transform.WorldRotation != 0)
            return CirclePolygon(box, circle, ref result);

        Vector2 circlePos = circle.Transform.WorldPosition;
        Contact contact = result.GetContact(0);
        contact.position = ColliderShapeUtility.FindClosestPointOnBox(box, circlePos, out result.normal);

        // deal with circles whos center is in the box first since its cheaper to see if we are contained
        if (Collisions.BoxContainsPoint(box, circlePos))
        {
            result.normal = Lib.Math.Normalize(result.normal);
            //kinda janky, but it works
            Vector2 res = circlePos * result.normal - contact.position * result.normal;
            if (res.Y == 0)
                contact.penetration = MathF.Abs(res.X) + circle.Radius;
            else
                contact.penetration = MathF.Abs(res.Y) + circle.Radius;
            //result.normal = -result.normal;
            return true;
        }

        float sqrDistance = Vector2.DistanceSquared(contact.position, circlePos);

        // see if the point on the box is less than radius from the circle
        if (sqrDistance <= circle.Radius * circle.Radius)
        {
            result.normal = circlePos - contact.position;
            contact.penetration = result.normal.Length() - circle.Radius;

            Lib.Math.Normalize(ref result.normal);
            result.contactCount = 1;

            return true;
        }

        return false;
    }
    public static bool CircleCapsule(CircleShape circle, CapsuleShape capsule, ref Manifold result)
    {
        //we pick the "most relevant circle" to do collision with.
        //Basically, we find the closest point to our shape on the capsule line
        //and do a circle collision there.
        Vector2 circlePos = circle.Transform.WorldPosition;
        Vector2 closestPoint = Collisions.ClosestPointOnLine(capsule.Start, capsule.End, circlePos);
        return CircleCircle(circlePos, circle.Radius, closestPoint, capsule.Radius, ref result);
    }
    public static bool CirclePolygon(in PolygonShape poly, in CircleShape circle, ref Manifold result)
    {
        return CirclePolygon(poly, circle.Transform.WorldPosition, circle.Radius, ref result);
    }
    /*
    public static bool CirclePolygon(in PolygonShape poly, in Vector2 circPos, in float radius, ref Manifold result)
    {
        result.contactCount = 0;

        // Find edge with minimum penetration
        // Exact concept as using support points in Polygon vs Polygon
        float separation = float.MinValue;
        int faceNormal = 0;
        for (int i = 0; i < poly.VertexCount; ++i)
        {
            float s = Vector2.Dot(-poly.EdgeNormals[i], circPos - poly.TransformedVertices[i]);

            if (s > radius)
                return false;

            if (s > separation)
            {
                separation = s;
                faceNormal = i;
            }
        }

        Contact c = result.GetContact(0);

        // Check to see if center is within polygon
        if (separation < float.Epsilon)
        {
            result.normal = -poly.EdgeNormals[faceNormal];
            c.position = result.normal * radius +circPos;
            c.depth = radius;
            return false;
        }

        // Grab face's vertices
        Vector2 v1 = poly.TransformedVertices[faceNormal];
        Vector2 v2 = poly.TransformedVertices[faceNormal + 1 < poly.VertexCount ? faceNormal + 1 : 0];

        // Determine which voronoi region of the edge center of circle lies within
        float dot1 = Vector2.Dot(circPos - v1, v2 - v1);
        float dot2 = Vector2.Dot(circPos - v2, v1 - v2);
        c.depth = radius - separation;

        // Closest to v1
        if (dot1 <= 0.0f)
        {
            if (Vector2.DistanceSquared(circPos, v1) > radius * radius)
                return false;

            result.normal = Lib.Math.Normalize(v1 - circPos);
            c.position = v1;
            result.contactCount = 1;
        }

        // Closest to v2
        else if (dot2 <= 0.0f)
        {
            if (Vector2.DistanceSquared(circPos, v2) > radius * radius)
                return false;

            result.normal = Lib.Math.Normalize(v2 - circPos);
            c.position = v2;
            result.contactCount = 1;
        }

        // Closest to face
        else
        {
            Vector2 n = poly.EdgeNormals[faceNormal];
            if (Vector2.Dot(circPos - v1, n) > radius)
                return false;

            result.normal = n;
            c.position = result.normal * radius + circPos;
            result.contactCount = 1;
        }
        return true;
    }*/

    
    public static bool CirclePolygon(PolygonShape poly, Vector2 circPos, float radius, ref Manifold result)
    {
        Contact c = result.GetContact(0);
        c.penetration = float.MaxValue;
        result.contactCount = 0;

        float distanceSquared;
        Vector2 closestPoint = PolygonShape.GetClosestPointOnPolygonToPoint(poly.TransformedVertices, circPos, out distanceSquared,
            out result.normal);
        bool circleCenterInsidePoly = Collisions.PolygonContainsPoint(poly, circPos);
        if (distanceSquared > radius * radius && !circleCenterInsidePoly)
            return false;

        Vector2 axis;
        float axisDepth;
        float minA, maxA, minB, maxB;

        for (int i = 0; i < poly.TransformedVertices.Length; i++)
        {
            Vector2 va = poly.TransformedVertices[i];
            Vector2 vb = poly.TransformedVertices[(i + 1) % poly.TransformedVertices.Length];

            Vector2 edge = vb - va;
            axis = Lib.Math.Normalize(-edge.Y, edge.X);

            ProjectVertices(poly.TransformedVertices, axis, out minA, out maxA);
            ProjectCircle(circPos, radius, axis, out minB, out maxB);

            if (minA >= maxB || minB >= maxA)
            {
                return false;
            }

            axisDepth = MathF.Min(maxB - minA, maxA - minB);

            if (axisDepth < c.penetration)
            {
                c.penetration = axisDepth;
                result.normal = axis;
            }
        }

        axis = closestPoint - circPos;
        axis = Lib.Math.Normalize(axis);

        ProjectVertices(poly.TransformedVertices, axis, out minA, out maxA);
        ProjectCircle(circPos, radius, axis, out minB, out maxB);

        if (minA >= maxB || minB >= maxA)
        {
            return false;
        }

        axisDepth = MathF.Min(maxB - minA, maxA - minB);

        if (axisDepth < c.penetration)
        {
            c.penetration = axisDepth;
            result.normal = axis;
        }

        Vector2 direction = poly.Transform.WorldPosition - circPos;

        if (Vector2.Dot(direction, result.normal) < 0f)
        {
            result.normal = -result.normal;
        }

        c.position = circPos + result.normal * radius;
        result.contactCount = 1;

        return true;
    }
    private static void ProjectCircle(Vector2 center, float radius, Vector2 axis, out float min, out float max)
    {
        Vector2 dirAndRadius = axis * radius;

        Vector2 p1 = center + dirAndRadius;
        Vector2 p2 = center - dirAndRadius;

        min = Vector2.Dot(p1, axis);
        max = Vector2.Dot(p2, axis);

        if (min > max)
        {
            float t = min;
            min = max;
            max = t;
        }
    }

    #endregion
    #region Box
    public static bool BoxBox(in BoxShape box1, in BoxShape box2, ref Manifold result)
    {
        //TODO: Find a box-box collider. It should be SUPER fast.
        return PolygonPolygon(box1, box2, ref result);
    }
    #endregion
    #region Capsule
    public static bool CapsuleCapsule(in CapsuleShape capsule1, in CapsuleShape capsule2, ref Manifold result)
    {
        //vectors between line endpoints
        Vector2 v0 = capsule2.Start - capsule1.Start;
        Vector2 v1 = capsule2.End - capsule1.Start;
        Vector2 v2 = capsule2.Start - capsule1.End;
        Vector2 v3 = capsule2.End - capsule1.End;

        //squared distances
        float d0 = Vector2.Dot(v0, v0);
        float d1 = Vector2.Dot(v1, v1);
        float d2 = Vector2.Dot(v2, v2);
        float d3 = Vector2.Dot(v3, v3);

        //best potential endpoint on capsule1
        Vector2 bestA;
        if (d2 < d0 || d2 < d1 || d3 < d0 || d3 < d1)
            bestA = capsule1.End;
        else
            bestA = capsule1.Start;

        //select point on capsule1 nearest to best potential endpoint on capsule2, and vice-versa
        Vector2 bestB = Collisions.ClosestPointOnLine(capsule2.Start, capsule2.End, bestA);
        bestA = Collisions.ClosestPointOnLine(capsule1.Start, capsule1.End, bestB);
        if (bestA == bestB)
        {   //if they're equal, that means our capsule lines are intersecting
            //which means we need to get the perpendicular normal to the smallest squared distance.
            Contact contact = result.GetContact(0);
            contact.position = bestA; //arbitrary contact point.
            float min = MathF.Min(MathF.Min(d0, d1), MathF.Min(d2, d3));
            if (min == d0)
            {
                contact.penetration = MathF.Sqrt(d0);
                result.normal = Lib.Math.Left(Lib.Math.Normalize(v0));
            }
            else if (min == d1)
            {
                contact.penetration = MathF.Sqrt(d1);
                result.normal = Lib.Math.Left(Lib.Math.Normalize(v1));
            }
            else if (min == d2)
            {
                contact.penetration = MathF.Sqrt(d2);
                result.normal = Lib.Math.Left(Lib.Math.Normalize(v2));
            }
            else
            {
                contact.penetration = MathF.Sqrt(d3);
                result.normal = Lib.Math.Left(Lib.Math.Normalize(v3));
            }
            return true;
        }

        bool ret = CircleCircle(bestA, capsule1.Radius, bestB, capsule2.Radius, ref result);
        if (ret)
        {
            //need to fix contact point.
            result.GetContact(0).position = bestA + result.normal * capsule1.Radius;
            return true;
        }
        return false;
    }

    public static bool CapsulePolygon(in CapsuleShape capsule, in PolygonShape polygon, ref Manifold result)
    {
        float retDepth = float.MinValue;
        Vector2 retNormal = Vector2.Zero;
        Vector2 point = Vector2.Zero;
        Contact contact = result.GetContact(0);
        for (int i = 0; i < polygon.TransformedVertices.Length; i++)
        {
            Vector2 closestPoint = Collisions.ClosestPointOnLine(capsule.Start, capsule.End, polygon.TransformedVertices[i]);
            bool ret = CirclePolygon(polygon, closestPoint, capsule.Radius, ref result);
            if (ret && retDepth < contact.penetration)
            {
                retDepth = contact.penetration;
                retNormal = result.normal;
                point = closestPoint;
            }
        }
        result.normal = retNormal;
        contact.penetration = retDepth;
        contact.position = point;

        return retDepth != float.MinValue;
    }
    #endregion
    #region Polygon

    private static void ProjectVertices(in Vector2[] vertices, in Vector2 axis, out float min, out float max)
    {
        min = float.MaxValue;
        max = float.MinValue;

        for (int i = 0; i < vertices.Length; i++)
        {
            Vector2 v = vertices[i];
            float proj = Vector2.Dot(v, axis);

            if (proj < min) { min = proj; }
            if (proj > max) { max = proj; }
        }
    }
    public static bool PolygonPolygon(PolygonShape poly1, PolygonShape poly2, ref Manifold result)
    {
        result.contactCount = 0;

        //Check for separating axis on A's normals
        int edgeA;
        float penetrationA = FindLeastPenetrationAxis(poly1, poly2, out edgeA);

        if (penetrationA >= 0)
            return false;

        //Check for separating axis on B's normals
        int edgeB;
        float penetrationB = FindLeastPenetrationAxis(poly2, poly1, out edgeB);

        if (penetrationB >= 0)
            return false;

        int referenceIndex;
        //Make sure we always point from A to B for consistent results
        bool flip;

        PolygonShape refPoly, incPoly;

        if (Lib.Math.BiasGreaterThan(penetrationA, penetrationB))
        {
            refPoly = poly1;
            incPoly = poly2;
            referenceIndex = edgeA;
            flip = false;
        }
        else
        {
            refPoly = poly2;
            incPoly = poly1;
            referenceIndex = edgeB;
            flip = true;
        }

        Vector2[] incidentEdge;
        GetIncidentEdge(out incidentEdge, refPoly, incPoly, referenceIndex);

        //Set up vertices
        Vector2 v1 = refPoly.TransformedVertices[referenceIndex];
        Vector2 v2 = refPoly.TransformedVertices[(referenceIndex + 1) % refPoly.VertexCount];

        Vector2 tangent = Lib.Math.Normalize(v2 - v1);

        Vector2 refEdgeNormal = new Vector2(-tangent.Y, tangent.X);

        float negSide = -Vector2.Dot(tangent, v1);
        float posSide = Vector2.Dot(tangent, v2);

        // Due to floating point error, possible to not have required points
        if (Clip(-tangent, negSide, ref incidentEdge) < 2)
            return false;

        if (Clip(tangent, posSide, ref incidentEdge) < 2)
            return false;

        result.normal = flip ? -refEdgeNormal : refEdgeNormal;

        // Keep points behind reference face
        float refC = Vector2.Dot(refEdgeNormal, v1);
        int cp = 0; // clipped points behind reference face
        for (int i = 0; i < 2; i++)
        {
            float separation = Vector2.Dot(refEdgeNormal, incidentEdge[i]) - refC;
            if (separation <= 0.0f)
            {
                Contact c = result.GetContact(cp++);
                c.position = incidentEdge[i];
                c.penetration = -separation;
            }
        }

        if (cp == 0)
            return false;
        result.contactCount = cp;
        return true;
    }

    private static float FindLeastPenetrationAxis(PolygonShape a, PolygonShape b, out int face)
    {
        float bestDistance = float.MinValue;
        face = 0;

        for (int i = 0; i < a.VertexCount; i++)
        {
            //Get normal of A's face
            Vector2 n = a.EdgeNormals[i];

            //Get furthest point in negative normal direction
            Vector2 s = Vector2.Zero;
            float minProjection = float.MaxValue;

            for (int z = 0; z < b.VertexCount; z++)
            {
                Vector2 vertex = b.TransformedVertices[z];
                float projection = Vector2.Dot(vertex, -n);

                //If vertex is furthest, projection is greatest
                if (projection < minProjection)
                {
                    minProjection = projection;
                    s = vertex;
                }
            }

            //Get vertex on A's face
            Vector2 v = a.TransformedVertices[i];

            //Find penetration distance
            float d = Vector2.Dot(n, v - s);

            //Store greatest distance
            if (d > bestDistance)
            {
                bestDistance = d;
                face = i;
                if (bestDistance >= 0)
                    return bestDistance; //early out, we're not colliding.
            }
        }

        return bestDistance;
    }

    private static void GetIncidentEdge(out Vector2[] face,
        PolygonShape refP, PolygonShape incP, int referenceIndex)
    {
        face = new Vector2[2];
        //Retrieve the reference normal
        Vector2 n = refP.EdgeNormals[referenceIndex];

        //Find face whose normal is most normal (perpendicular) to the normal (oh...)
        int incidentFace = -1;
        float minDot = float.MaxValue;

        for (int i = 0; i < incP.VertexCount; i++)
        {
            float dot = Vector2.Dot(n, incP.EdgeNormals[i]);
            if (dot < minDot)
            {
                minDot = dot;
                incidentFace = i;
            }
        }

        //Get world space face
        face[0] = incP.TransformedVertices[incidentFace];
        face[1] = incP.TransformedVertices[(incidentFace + 1) % incP.VertexCount];
    }

    private static int Clip(Vector2 n, float c, ref Vector2[] face)
    {
        int clippedPoints = 0;
        Vector2[] res = { face[0], face[1] };

        //Get distance to line (ax + by = -c, n = (a, b))
        float d1 = Vector2.Dot(n, face[0]) - c;
        float d2 = Vector2.Dot(n, face[1]) - c;

        //If behind plane, clip
        //Here we aren't actually clipping, but we are just incrementing the count
        if (d1 <= 0) res[clippedPoints++] = face[0];
        if (d2 <= 0) res[clippedPoints++] = face[1];

        //Check whether one of the points is ahead and other behind
        //(-) * (+) = (-)
        if (d1 * d2 < 0)
        {
            //Intersect
            float t = d1 / (d1 - d2);
            res[clippedPoints] = face[0] + (face[1] - face[0]) * t;
            clippedPoints++;
        }

        face[0] = res[0];
        face[1] = res[1];

        return clippedPoints;
    }
    #endregion
}